
"""
    build_freq_list(::Type{M}, sbuf::SequenceBuffer{PairedReads}, range::UnitRange{Int}) where {M<:AbstractMer}

Build a sorted list (vector) of kmer counts (MerFreq), serially and in memory.

This function is a serial and in memory `MerFreq` list builder that can build a
kmer count from a PairedReads datastore on it own (if you have memory and time),
but it is also intended to be composed into other multi-process or multi-threaded
kmer counting strategies.

This method estimates roughly how many kmers will be generated by the reads
specified by `range` in the dataset. It then pre-allocates an array to contain
them. It then collects the kmers, sorts, them, and then collapses them into a
list of counts sorted by the kmer.
"""
function build_freq_list(::Type{M}, sbuf::SequenceBuffer{PairedReads}, range::UnitRange{Int}) where {M<:AbstractMer}
    max_read_size = maxseqlen(ReadDatastores.datastore(sbuf))
    chunk_mers = Vector{M}(undef, length(range) * (max_read_size - BioSequences.ksize(M) + 1))
    wi = firstindex(chunk_mers)
    read_sequence = LongDNASeq()
    @inbounds for i in range
        for mer in each(M, load_sequence!(sbuf, i, read_sequence))
            chunk_mers[wi] = canonical(mer)
            wi = wi + 1
        end
    end
    resize!(chunk_mers, wi - 1)
    return collapse_into_freqs(chunk_mers)
end

"""
    build_freq_list(::Type{M}, sbuf::SequenceBuffer{PairedReads}, range::UnitRange{Int}, chunk_size::Int) where {M<:AbstractMer}

Build a sorted list (vector) of kmer counts (MerFreq), serially and in memory.

This function is a serial and in memory `MerFreq` list builder that can build a
kmer count from a PairedReads datastore on it own (if you have memory and time),
but it is also intended to be composed into other multi-process or multi-threaded
kmer counting strategies.

This method pre-allocates space for `chunk_size` kmers, and iterates over kmers
in the reads in the dataset specified by `range` until the buffer is filled.
The mers are then collapsed into a list of counts, sorted by the kmer.
This list is then merged into another output list.
This process repeats for many chunks of kmers, building up the output list.

This method is useful for situations where you don't want (or have the space) to
allocate a buffer to collect all the kmers in the dataset all in one go.
"""
function build_freq_list(::Type{M}, sbuf::SequenceBuffer{PairedReads}, range::UnitRange{Int}, chunk_size::Int) where {M<:AbstractMer}
    chunk_mers = Vector{M}(undef, chunk_size)
    chunk_freqs = Vector{MerFreq{M}}()
    sizehint!(chunk_freqs, chunk_size)
    output = Vector{MerFreq{M}}()
    
    read = first(range)
    lastread = last(range)
    read_sequence = LongDNASeq()
    
    mergen = each(M, load_sequence!(sbuf, read, read_sequence))
    mernext = iterate(mergen)
    chunkfill = 1
    
    @inbounds while read <= lastread
        #Â Fill the `chunk_mers` buffer with a load of kmers.
        while mernext !== nothing && chunkfill <= chunk_size
            chunk_mers[chunkfill] = canonical(mernext[1])
            chunkfill = chunkfill + 1
            mernext = iterate(mergen, mernext[2])
        end
        if isnothing(mernext) # Current read is consumed.
            read = read + 1
            if read <= lastread # There are more reads to come.
                mergen = each(M, load_sequence!(sbuf, read, read_sequence))
                mernext = iterate(mergen)
            else # There are no more reads to come.
                resize!(chunk_mers, chunkfill - 1)
                collapse_into_freqs!(chunk_mers, chunk_freqs)
                merge_into_sorted!(output, chunk_freqs)
                return output
            end
        end
        if chunkfill > chunk_size # The buffer is full, time to merge into output.
            collapse_into_freqs!(chunk_mers, chunk_freqs)
            merge_into_sorted!(output, chunk_freqs)
            chunkfill = 1
        end
    end
end