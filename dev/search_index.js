var documenterSearchIndex = {"docs":
[{"location":"DeBruijnGraph/#de-Bruijn-Graph-type-1","page":"-","title":"de Bruijn Graph type","text":"","category":"section"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"A fundamental approach for de-novo gene assembly is to use make use of de Bruijn graphs. The graph is used to represent fragments of reads (mostly starting with kmers) as vertices and overlaps between these fragments as edges. DeBruijnGraph type is a special type of SequenceGraph. It is also made up of two fields:","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"nodes\nlinks","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"struct DeBruijnGraph\n    nodes::Vector{SequenceGraphNode}\n    links::Vector{Vector{SequenceGraphLink}}\nend","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"We initialize a DeBruijnGraph using the deBruijn_constructor function. This is mainly due to the fact that arbitrary links between two vertices are not allowed in the de Bruijn graph formalism. The constructor receives as input a list of kmers and generates the deBruijn_Graph where each kmer is a unique vertex and each overlap  of length k-1 is represented with an edge.","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"kmer_vector = generate_random_kmers(DNA,4,10)\ndbg = deBruijn_constructor(kmer_vector)\n\nDeBruijnGraph(SequenceGraphNode[SequenceGraphNode{Kmer{DNA,4}}(CGCC, true), SequenceGraphNode{Kmer{DNA,4}}(TCTG, true), SequenceGraphNode{Kmer{DNA,4}}(TGTG, true), SequenceGraphNode{Kmer{DNA,4}}(GAAG, true), SequenceGraphNode{Kmer{DNA,4}}(GGCA, true), SequenceGraphNode{Kmer{DNA,4}}(ACGA, true), SequenceGraphNode{Kmer{DNA,4}}(CGCT, true), SequenceGraphNode{Kmer{DNA,4}}(TCTC, true), SequenceGraphNode{Kmer{DNA,4}}(TACG, true), SequenceGraphNode{Kmer{DNA,4}}(GCAT, true)], Array{SequenceGraphLink,1}[[], [], [], [], [SequenceGraphLink(-5, 10, 1)], [], [], [], [SequenceGraphLink(-9, 6, 1)], []])","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"We can use the fastq readers to work on real data. The example below generates the set of unique kmers from 5-long reads. The kmer size is set to 15.","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"r = FASTQ.Reader(open(\"URnano_ecoli.fastq\", \"r\"))\nEcoli_reads = Vector{BioSequence{DNAAlphabet{4}}}()\n\n## get first 5 reads\nfor i in 1:5\n    next_seq = iterate(r)\n    seq = sequence(next_seq[1])\n    next_seq = iterate(r,next_seq[2])\n    push!(Ecoli_reads,seq)\nend\nkmers = new_extract_canonical_kmers(Ecoli_reads,15)","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"The output is a set of kmers in their canonical form:","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"Set(Kmer{DNA,15}[AAAATATCTCGTTTT, TAAACCAGTCGCCGC, TTCGACATTACCCAG, CGCCCTGCCAGCAGT, TAATATTGTTCCATT, TGGTAATGGTCACAG, AAAAATTAAGCAGGA, ATATAAGTTATATCA, GCCCGATCTGTCTCC, GATTTCTCCGGGCCA  …  TGAGCGATTGCCTGA, CGGAGCAGCAGTGTC, AAAATCGTACATACC, GTCGCCTGATGCCTG, GTCAGCGAACCTTCC, CGCCGCTCACCGCCG, TGGATGAACGTTCAT, AATATGTCACAATTT, ATGCGATAGCAGGGG, GTAGAAAGCTCGTGG, CGATTGGTTTAAGAC])","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"Example data for checking node merging :","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"kmer_vector2 = Vector([DNAKmer{4}(\"ATTC\"),DNAKmer{4}(\"TTCG\"),DNAKmer{4}(\"TCGT\"),\n        DNAKmer{4}(\"AATC\"),DNAKmer{4}(\"AATG\"),DNAKmer{4}(\"CGTA\"),DNAKmer{4}(\"CGTC\")])","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"DeBruijnGraph for the above kmers:","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"DeBruijnGraph(Dict{Int64,SequenceGraphNode}(7=>SequenceGraphNode{Kmer{DNA,4}}(ACGA, true),4=>SequenceGraphNode{Kmer{DNA,4}}(CGTC, true),2=>SequenceGraphNode{Kmer{DNA,4}}(AATG, true),3=>SequenceGraphNode{Kmer{DNA,4}}(ATTC, true),5=>SequenceGraphNode{Kmer{DNA,4}}(CGTA, true),6=>SequenceGraphNode{Kmer{DNA,4}}(CGAA, true),1=>SequenceGraphNode{Kmer{DNA,4}}(AATC, true)), Dict(7=>[SequenceGraphLink(-7, 6, -3)],4=>[SequenceGraphLink(4, 7, -3)],2=>[],3=>[SequenceGraphLink(3, 1, -3), SequenceGraphLink(3, 2, -3)],5=>[SequenceGraphLink(5, 7, -3)],6=>[SequenceGraphLink(-6, -3, -3)],1=>[]), 4)","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"Then we apply node merging:","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"DeBruijnGraph(Dict{Int64,SequenceGraphNode}(7=>SequenceGraphNode{BioSequence{DNAAlphabet{4}}}(ACGAAT, true),4=>SequenceGraphNode{Kmer{DNA,4}}(CGTC, true),2=>SequenceGraphNode{Kmer{DNA,4}}(AATG, true),5=>SequenceGraphNode{Kmer{DNA,4}}(CGTA, true),1=>SequenceGraphNode{Kmer{DNA,4}}(AATC, true)), Dict(7=>[SequenceGraphLink(-7, 6, -3), SequenceGraphLink(-7, 1, -3), SequenceGraphLink(-7, 2, -3)],4=>[SequenceGraphLink(4, 7, -3)],2=>[],5=>[SequenceGraphLink(5, 7, -3)],1=>[]), 4)","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"So the nodes with nodeID 6 and 3 are collapsed into node 7 and we can see that both outgoing edges of 3 are given to node 7.","category":"page"},{"location":"DeBruijnGraph/#Saving-to-gfa-1","page":"-","title":"Saving to gfa","text":"","category":"section"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"Below is an example code for saving a SequenceDistanceGraph to GFA file. This allows us to load and visualize the graph using graph visualization tools.","category":"page"},{"location":"DeBruijnGraph/#","page":"-","title":"-","text":"# A helpful function to let me run Bandage to visualize graphs.\nconst BANDAGE_BIN = \"/Applications/Bandage.app/Contents/MacOS/Bandage\"\nfunction draw_graph(gr)\n    filename = tempname()\n    BioSequenceGraphs.dump_to_gfa1(gr, filename)\n    run(`$BANDAGE_BIN image $filename.gfa $filename.png --height 500`)\n    run(`open $filename.png`)\nend\nfunction show_graph(gr)\n    filename = tempname()\n    BioSequenceGraphs.dump_to_gfa1(gr, filename)\n    run(`$BANDAGE_BIN load $filename.gfa`)\nend","category":"page"},{"location":"api/SequenceDistanceGraph/#API:-Graph-types-1","page":"Graphs","title":"API: Graph types","text":"","category":"section"},{"location":"api/SequenceDistanceGraph/#The-SequenceDistanceGraph-1","page":"Graphs","title":"The SequenceDistanceGraph","text":"","category":"section"},{"location":"api/SequenceDistanceGraph/#","page":"Graphs","title":"Graphs","text":"SequenceDistanceGraph","category":"page"},{"location":"api/SequenceDistanceGraph/#GenomeGraphs.SequenceDistanceGraph","page":"Graphs","title":"GenomeGraphs.SequenceDistanceGraph","text":"The SequenceDistanceGraph is a representation of a genome assembly. Sequences are contained in nodes, and the distances are represented by links.\n\nA singe node represents a sequence and its reverse complement. Every node has a correlative ID starting from 1. For every node X in the graph, the negative ID -X is mapped to the reverse complement of X. This mapping is virtual: Only one node is stored in the graph. This is because every node has an orientaton: Each node has a positive end (+), and a negative end (-). So when a node is accessed with (or traversed by entering) the positive end the node yields the stored sequence. Conversely, when a node is accessed with (or traversed by entering) the negative end the node yelds the reverse complement of the stored sequence. In this way the positive end can be thought of as the sequence start, and the negative end can be thought of as the sequence end.\n\nA single distance between two sequences is represented as a single link. Every link connects two node ends and contains a distance (they take the form ([+, -]n1, [+, -]n2, [+, -]dist)). A link connects two node ends, and so the order of the signed nodes in the links does not change the link. If the distance in a link is negative, this represents an overlap between two sequences. These overlaps must be \"perfect overlaps\".\n\nThis SequenceDistanceGraph type is only intended to be interacted with directly by developers and people who know what they are doing. Most tasks an end user wants to do to manipulate or query a graph can be \n\n\n\n\n\n","category":"type"},{"location":"api/SequenceDistanceGraph/#Public-/-Safe-1","page":"Graphs","title":"Public / Safe","text":"","category":"section"},{"location":"api/SequenceDistanceGraph/#Accessors-1","page":"Graphs","title":"Accessors","text":"","category":"section"},{"location":"api/SequenceDistanceGraph/#","page":"Graphs","title":"Graphs","text":"name\nn_nodes\nsequence\nfind_link\nforward_links\nbackward_links","category":"page"},{"location":"api/SequenceDistanceGraph/#GenomeGraphs.name","page":"Graphs","title":"GenomeGraphs.name","text":"Get the name of the graph. Defaults to the symbol :sdg.\n\n\n\n\n\n","category":"function"},{"location":"api/SequenceDistanceGraph/#GenomeGraphs.n_nodes","page":"Graphs","title":"GenomeGraphs.n_nodes","text":"Get the number of nodes in the sequence distance graph sg.\n\n\n\n\n\n","category":"function"},{"location":"api/SequenceDistanceGraph/#GenomeGraphs.sequence","page":"Graphs","title":"GenomeGraphs.sequence","text":"sequence(sg::SequenceDistanceGraph, n::NodeID)\n\nGet the full sequence of a node in a sequence distance graph using its correlative node id n.\n\nnote: Note\nsequence accepts a NodeID that can be positive or negative. Nodes represent stretches of sequence in a canonical orientation, if you ask for for the sequence of say the third node, the positive node id 3 (which denotes traversing the third node in the forward direction), gives you the canonical sequence. If you use the negative ID -3 (which denotes traversing the third node in the reverse direction), you will get the reverse complement of the node's canonical (forward) sequence.\n\nnote: Note\nIt is safe to modify the returned sequence without screwing up your graph, yet thanks to BioSequences.jl's copy on write system for LongSequences, data copying will only occur if nessecery. You get the best of both worlds.\n\n\n\n\n\nGet the sequence of the underlying SequenceDistanceGraph node.\n\n\n\n\n\n","category":"function"},{"location":"api/SequenceDistanceGraph/#Internal-/-Unsafe-1","page":"Graphs","title":"Internal / Unsafe","text":"","category":"section"},{"location":"api/SequenceDistanceGraph/#Accessors-2","page":"Graphs","title":"Accessors","text":"","category":"section"},{"location":"api/SequenceDistanceGraph/#","page":"Graphs","title":"Graphs","text":"check_node_id\nnodes\nnode_unsafe\nsequence_unsafe\nlinks\nlinks_unsafe","category":"page"},{"location":"api/SequenceDistanceGraph/#GenomeGraphs.links","page":"Graphs","title":"GenomeGraphs.links","text":"Get a reference to the vector of vectors of links in a graph sg.\n\nwarning: Warning\nIt is a bad idea to edit this vector yourself unless you know what you are doing.\n\n\n\n\n\nlinks(sg::SequenceGraph, n::NodeID)\n\nGet a **reference** to a vector storing all the links of a node in a\n`SequenceDistanceGraph`, the node is specified using its correlative node id `n`.\n\nnote: Note\nlinks accepts a NodeID that can be positive or negative. E.g. providing either 5 or -5 both mean node 5 in a graph, and so you will get the links for node 5.\n\nwarning: Warning\nThis method returns a reference to an underlying links vector that the SequenceDistanceGraph owns - NOT a copy! Messing with this will screw up your graph. So this method is not recommended or exported - unless you really know what you're doing.\n\n\n\n\n\n","category":"function"},{"location":"types/graphs/#The-Sequence-Distance-Graph-(SDG)-1","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"","category":"section"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"SequenceDistanceGraph","category":"page"},{"location":"types/graphs/#Querying-an-SDG-for-basic-properties-1","page":"The Sequence Distance Graph (SDG)","title":"Querying an SDG for basic properties","text":"","category":"section"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"nodes\nn_nodes\neach_node_id\nlinks\nnode\nsequence","category":"page"},{"location":"types/graphs/#GenomeGraphs.each_node_id","page":"The Sequence Distance Graph (SDG)","title":"GenomeGraphs.each_node_id","text":"Iterate over every node ID in the sequence distance graph sg.\n\n\n\n\n\n","category":"function"},{"location":"types/graphs/#Manually-editing-an-SDG-by-manipulating-nodes-and-links-1","page":"The Sequence Distance Graph (SDG)","title":"Manually editing an SDG by manipulating nodes and links","text":"","category":"section"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"It is not recommended you do this if you are a high level user. However these small editing operations are required for developers. If you find yourself needing these methods, you will have to explicitly import them, as they are not exported from the module.","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"If you find yourself wanting to edit the graph manually, it's a good idea to ask the package authors listed in the Project.toml or .github/CODEOWNERS.","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"add_node!\nremove_node!\nadd_link!\nremove_link!\ndisconnect_node!","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"#Code example for testing the error correction and simplifying the graph","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"In the example below we generate a toy graph from 4-mers which contain a bubble. As for now, we make use of randomly generated coverage information for","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"using BioSequences\nusing BioSequenceGraphs\n\nkmerlist = Vector{DNAKmer{4}}([DNAKmer{4}(\"ATAC\"),DNAKmer{4}(\"TACG\"),DNAKmer{4}(\"TACC\"),DNAKmer{4}(\"ACGA\"),DNAKmer{4}(\"CGAA\"),DNAKmer{4}(\"GAAT\"),DNAKmer{4}(\"AATC\"),DNAKmer{4}(\"ACCA\"),DNAKmer{4}(\"CCAA\"),DNAKmer{4}(\"CAAT\")])\nsdg = SequenceDistanceGraph(kmerlist,true)","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"The new SequenceDistanceGraph constructor takes as input a list of kmerlist (not necessarily sorted or in canonical form) and a boolean for whether to do error correction or not. Then by using the coverage information generated randomly, simplifies the graph. The resulting SDG before and after the error correction steps are as follows:","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"***Before:***","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"SequenceDistanceGraph{BioSequence{DNAAlphabet{2}}}(SDGNode{BioSequence{DNAAlphabet{2}}}[SDGNode{BioSequence{DNAAlphabet{2}}}(AATC, false), SDGNode{BioSequence{DNAAlphabet{2}}}(ATAC, false), SDGNode{BioSequence{DNAAlphabet{2}}}(ATTCGTA, false), SDGNode{BioSequence{DNAAlphabet{2}}}(ATTGGTA, false)], Array{DistanceGraphLink,1}[[DistanceGraphLink(1, 3, -3), DistanceGraphLink(1, 4, -3)], [DistanceGraphLink(-2, -4, -3), DistanceGraphLink(-2, -3, -3)], [DistanceGraphLink(3, 1, -3), DistanceGraphLink(-3, -2, -3)], [DistanceGraphLink(4, 1, -3), DistanceGraphLink(-4, -2, -3)]])","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"***After:***","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"SequenceDistanceGraph{BioSequence{DNAAlphabet{2}}}(SDGNode{BioSequence{DNAAlphabet{2}}}[SDGNode{BioSequence{DNAAlphabet{2}}}(GATTCGTAC, false)], Array{DistanceGraphLink,1}[[]])","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"So the algorithm first generates a sdg with collapsing all simple paths using the initial kmer list. Then at the next stage the low covered bubble branch is removed and path collapsing is applied one more time. This results in a sdg with a whole single node, a perfect unitig.","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"##TODO:","category":"page"},{"location":"types/graphs/#","page":"The Sequence Distance Graph (SDG)","title":"The Sequence Distance Graph (SDG)","text":"Implement the sdg constructor to take as input a list of reads instead of kmers and generate all kmer + coverage information from them.","category":"page"},{"location":"man/guide/#Package-Guide-1","page":"Guide","title":"Package Guide","text":"","category":"section"},{"location":"man/guide/#Installation-1","page":"Guide","title":"Installation","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"GenomeGraphs is made available to install through BioJulia's package registry.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Julia by default only watches the \"General\" package registry, so before you start, you should add the BioJulia package registry.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Start a julia terminal, hit the ] key to enter pkg mode (you should see the prompt change from julia> to pkg>), then enter the following command:","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"pkg> registry add https://github.com/BioJulia/BioJuliaRegistry.git","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"After you've added the registry, you can install GenomeGraphs from the julia REPL. Press ] to enter pkg mode again, and enter the following:","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"pkg> add GenomeGraphs","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"If you are interested in the cutting edge of the development, please check out the master branch to try new features before release.","category":"page"},{"location":"man/guide/#Creating-your-first-WorkSpace-1","page":"Guide","title":"Creating your first WorkSpace","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"You can create an empty genome graph workspace with the empty constructor:","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"using GenomeGraphs\n\nws = WorkSpace()","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Obviously this workspace is quite useless on its own!","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"You need a genome graph and information to project onto it before you can do any exploration or analysis. There are a few ways to get your first graph:","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Construct a de-Bruijn graph from raw sequencing reads.\nLoad a graph (such as produced from another assembler) from a GFAv1 file","category":"page"},{"location":"man/guide/#Constructing-your-first-de-Bruijn-graph-1","page":"Guide","title":"Constructing your first de-Bruijn graph","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Let's see how to do option number 1, and construct a de-Bruijn graph from raw sequencing reads. This can be achieved with a few simple steps:","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Prepare the sequencing reads & build a datastore.\nAdd the read datastore to a WorkSpace.\nRun the dbg process.\nRun the tip removal process.","category":"page"},{"location":"man/guide/#Preparing-the-sequencing-reads-1","page":"Guide","title":"Preparing the sequencing reads","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Let's prepare the sequencing reads.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"WorkSpaces store sequencing reads in ReadDatastores, provided by the ReadDatastores.jl package.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"GenomeGraphs uses (and re-exports types and methods from) ReadDatastores. ReadDatastores is a standalone package in its own right (although it was built in the first place for GenomeGraphs).","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"If you want to use ReadDatastores as a standalone package in another Bio(Julia) based project (and we recommend you do - the data stores are more efficient than text files), you can find standalone docs for the package here. Some types and methods documented there, are repeated in the Library section of this manual here, for convenience.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Anyway, let's see how to build a paired end reads datastore!","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"using GenomeGraphs\n\nfwq = open(FASTQ.Reader, \"test/ecoli_pe_R1.fastq\")\nrvq = open(FASTQ.Reader, \"test/ecoli_pe_R2.fastq\")\n\nds = PairedReads(fwq, rvq, \"ecoli-test-paired\", \"my-ecoli\", 250, 300, 0, FwRv)","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Here \"ecoli-test-paired\" is provided as the base filename of the datastore, the datastore is given the name of \"my-ecoli\", this name will be used to identify it in the workspace later.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"The minimum length for the reads is set at 250 base pairs, and the maximum length is set to 300 base pairs. Reads that are too short will be discarded, reads that are too long are truncated.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"note: Note\nThe insert size of the paired reads to 0, since I'm not sure of it and right now the value is optional.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"I set the orientation of the paired reads to FwRv. This is the default, and means for every pair of reads, read 1 is oriented in the forward direction, and read 2 is oriented backwards (forwards on the opposite strand). This orientation distinguishes regular paired-end reads from other paired read types like Long Mate Pairs.","category":"page"},{"location":"man/guide/#Add-datastore-to-the-WorkSpace-1","page":"Guide","title":"Add datastore to the WorkSpace","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Now the datastore is created, it can be added to a workspace.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"ws = WorkSpace()\nadd_paired_reads!(ws, ds)","category":"page"},{"location":"man/guide/#Run-the-dbg-process-1","page":"Guide","title":"Run the dbg process","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"GenomeGraphs comes with some very high-level methods in it's API, that we like to call processes. They perform some critical and common task as part of a larger workflow. Examples include constructing a de-Bruijn graph from sequencing reads, mapping reads to a graph, kmer counting and so on.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Once a workspace has an attached read datastore, you can run the dbg process to produce a first de-Bruijn graph of the genome.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"dbg!(BigDNAMer{61}, 10, ws, \"my-ecoli\")","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"warning: Warning\nSome steps of this process, especially the Kmer counting steps, may take a long time for big inputs. No parallelism or batching to disk is used currently (although it is planned). This process should take just about a minute for E.coli paired end reads with a decent coverage. So, be warned, for big stuff, performance may suuuuuuucck in these early days!","category":"page"},{"location":"man/guide/#Run-the-remove_tips-process-1","page":"Guide","title":"Run the remove_tips process","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Now you have a raw compressed de-Bruijn assembly graph. You can start to use it for analyses, and also try to improve its structure and resolve parts of the graph that represent error, repetitive content, and so forth. Some of these structures can be identified and resolved using only the topology of the graph, some require additional information sources (linked reads / long reads / and so on), to be incorporated into the workspace first.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Here let's see how to resolve a common structure, using only the graph topology.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Let's fix the tips of the graph.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Tips looks like this:","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"(Image: tips)","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"See how a piece of the assembly which should be one long stretch of sequence is broken into 3 pieces (red) because of the existence of two tips (blue). Such tips are defined topologically as very short segments which have one incoming neighbour, and no outgoing neighbour.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Tips are caused by sequencer errors that occur at the end of reads, because the sequencing by synthesis technique becomes more error prone over time; reagents are consumed and products generated as time progresses, making the base detection more difficult. Hence errors occur at the ends of reads, and erroneous kmers from the read ends are unlikely to have forward neighbours, and they end up forming tip nodes when they are incorporated into the de-Bruijn graph. ","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"you can remove these tips and improve the contiguity of the graph by using the remove_tips! process.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"remove_tips!(ws, 200)","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"The value of 200 provided is a size (in base pairs) threshold: Nodes are considered tips only if they have one ingoing neighbour, no outgoing neighbours, and are (in this case) smaller than 200 base pairs in length.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Once this process is finished you will have a collapsed de-Bruijn graph with the tips removed.","category":"page"},{"location":"man/guide/#Using-the-NodeView-interface-1","page":"Guide","title":"Using the NodeView interface","text":"","category":"section"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"Graphs can be complicated data structures. If you want an in depth explanation of the data-structure used to represent genome graphs, then head here.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"However, most people should not have to care about the internal structure of the graph.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"To make things as simple as possible, the NodeView type provides a single entry point for node-centric analyses. The NodeView wraps a point to a workspace's graph and contains a node id. A NodeView gives you acces to a node's underlying sequence, the nodes neighbouring nodes in the forward and backward directions, the reads mapped to a node, and kmer coverage over the node.","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"To get a NodeView of a node, use the node method on a WorkSpace, providing a node id number. A positive ID denotes a view of the node traversing it in the forward (canonical) direction. A negative ID denotes a view of the node, traversing it in the reverse complement direction.   ","category":"page"},{"location":"man/guide/#","page":"Guide","title":"Guide","text":"julia> n = node(ws, 3)\nA view of a graph node (node: 3, graph: sdg):\n  AAAAAACCTCCGCAACCCCATGTTTTCACATAACTGTTG…GCCATGACCGGCTGGCTGTCAGGCTGTCACTGATAATCA\n\n","category":"page"},{"location":"types/workspace/#Workspaces-1","page":"Workspaces","title":"Workspaces","text":"","category":"section"},{"location":"#GenomeGraphs-1","page":"Home","title":"GenomeGraphs","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A graph based genomics framework for the julia/BioJulia ecosystem.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"(Image: Latest release) (Image: MIT license)  (Image: Stable documentation) (Image: Pkg Status) (Image: Chat)","category":"page"},{"location":"#Introduction-1","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"GenomeGraphs is designed to do one thing - provide a framework that makes it simple for a human to work with genome graphs from scripts or interactively.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Graphs are the core representation used by genome assemblers to represent genome sequence models constructed from reads. At the time of writing it is fair to say that until recently, their use has been limited to the internals of genome assemblers, which are often treated as black boxes that output a series of flattened sequences in FASTA format.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The use of graphs has increased in recent years thanks to the GFA file format and developments in genome variation graphs and sequence to graph mappers.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"However, a lack of inter operation between graph-based tools, and limited tools for downstream graph-based analysis, contribute to a perceived complexity which maintains linear sequences and FASTA files as the typical unit of genomic sequence exchange.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Such flattening of graph representations within pipelines with multiple steps, that use different types of sequencing in an iterative fashion, produces ever-longer linear genome sequences through an information loss process.  As a result, genome assembly projects are prone to error propagation and difficult to reproduce and control.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To address these problems for the BioJulia ecosystem, GenomeGraphs provides a flexible framework for building and integrating information over genome graphs.","category":"page"},{"location":"#Framework-overview-1","page":"Home","title":"Framework overview","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This package implements a SequenceDistanceGraph type that represents sequences as nodes and the adjacency between sequences in links/edges. Rather than work directly with this graph data structure, you interact with a WorkSpace. A WorkSpace associates a SequenceDistanceGraph with raw sequencing reads,  sequence to graph mappings, and k-mer counts. The WorkSpace and the API  provides a working environment that enables you to project different kinds of  information over a graph, and navigate and analyse each node of a sequence graph.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Within the WorkSpace, you will find DataStore types permit random access to short, linked, and long read sequences stored on disk in BioSequences.jl's native bit encoding. Each datastore has an associated Mapper in the workspace that contains the output from mapping said reads onto the graph. KmerCounts allow you to compute k-mer coverage over the graph from sequencing data, enabling coverage analysis. Additional DistanceGraphs define alternative topologies over SequenceDistanceGraph nodes. They are typically used to represent longer range linkage information from various sequencing technologies.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Finally, a NodeView abstraction provides a proxy to a node, with methods to navigate a graph and access mapped data.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"This framework is intended to allow the user to expore genome graphs interactively and to create processing methods for assembly or downstream analyses.","category":"page"},{"location":"#TLDR;-Package-features-1","page":"Home","title":"TLDR; Package features","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Efficient on-disk (buffered) data stores for sequencing reads.\nA simple graph data-structure for representing assembled genomes.\nTODO: Transparent mapping of sequencing reads onto graphs.\nTODO: Kmer counts and coverage projection over genome graph nodes.\nWorkspaces binding a genome graph, mapped sequences, kmer counts, and annotation.\nDe-novo genome assembly utilities:\nde-Bruijn graph construction, with tip-clipping & bubble-popping.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"See the Guide section of the manual for a tutorial explaining how to get started using GenomeGraphs.","category":"page"}]
}
